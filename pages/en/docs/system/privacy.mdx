import { Callout, Steps, Tabs } from 'nextra/components'
import { FAQBox } from '@components'

# Privacy

We configure Tor and I2P to run your node anonymously.

Running your own Bitcoin and Lightning node at home makes you a direct,
sovereign peer on the Bitcoin network. However, if not configured without
privacy in mind, it also tells the world that there is someone with Bitcoin at
that address.

We'll also make it easy to connect to your node from outside your home network
as an added benefit.

True, it's only your IP address that is revealed, but using services like
[iplocation.net](https://www.iplocation.net), your physical address can be
determined quite accurately. Especially with Lightning, your IP address would be
widely used. We need to make sure that you keep your privacy.

## Tor Project

We use Tor, a free software built by the
[Tor Project](https://www.torproject.org). It allows you to anonymize internet
traffic by routing it through a network of nodes, hiding your location and usage
profile.

It is called "Tor" for "The Onion Router": information is routed through many
hops and encrypted multiple times. Each node decrypts only the layer of
information addressed to it, learning only the previous and the next hop of the
whole route. The data package is peeled like an onion until it reaches the final
destination.

### Preparation

Create `tor` group and user

```sh copy
$SU addgroup -S tor
```

```sh copy
$SU adduser \
    -S \
    -D \
    -H \
    -h /dev/null \
    -s /sbin/nologin \
    -G tor \
    -g tor \
    tor
```

### Install

```sh copy
$SU apk add tor
```

### Tor configuration

Bitcoin client will communicate directly with the Tor daemon to route all
traffic through the Tor network. We need to enable Tor to accept instructions
through its control port, with the proper authentication.

* Edit the Tor configuration

```sh copy
$SU cp /etc/tor/torrc.sample /etc/tor/torrc
$SU $EDITOR /etc/tor/torrc
```

* Uncomment, add or modify the following lines

```conf filename="/etc/tor/torrc" {7-8,12,16-19}
[...]
## Tor opens a SOCKS proxy on port 9050 by default -- even if you don't
## configure one below. Set "SOCKSPort 0" if you plan to run Tor only
## as a relay, and not make any local application connections yourself.
#SOCKSPort 9050 # Default: Bind to localhost:9050 for local connections.
#SOCKSPort 192.168.0.1:9100 # Bind to this address:port too.
SOCKSPort 9050
SOCKSPort unix:/var/run/tor/socks.sock WorldWritable
[...]
## The port on which Tor will listen for local connections from Tor
## controller applications, as documented in control-spec.txt.
ControlPort unix:/var/run/tor/control.sock GroupWritable RelaxDirModeCheck
## If you enable the controlport, be sure to enable one of these
## authentication methods, to prevent attackers from accessing it.
#HashedControlPassword 24:972860B76453A77B40CA2BB8C1A7982072093276A3D701AD685353
CookieAuthentication 1
CookieAuthFile /var/run/tor/control.authcookie
CookieAuthFileGroupReadable 1
DataDirectoryGroupReadable 1

############### This section is just for location-hidden services ###
[...]
```

* Start Tor and add service to runlevel

```sh copy
$SU rc-service tor start
$SU rc-update add tor default
```

* Ensure that the Tor service is working and listening at the default ports
`9050`

```sh copy
$SU netstat -lntup | grep LISTEN | grep tor
```

```sh filename="output"
tcp        0      0 127.0.0.1:9050          0.0.0.0:*               LISTEN      6432/tor
```

* Check the logs to see Tor in real time updates output logs. Exit with `Ctrl-C`

```sh copy
$SU tail -f /var/log/tor/notices.log
```

Not all network traffic is routed over the Tor network. But we now have the base
to configure sensitive applications to use it.

### `curl` and `git` through Tor

If you want to download files with `curl` and/or `git` through Tor, you can use
the `*_PROXY` environment variable. This is useful for downloading files from
the internet without revealing your IP address.

* Uncomment these lines in the default environment variables

```sh copy
$SU $EDITOR /etc/profile.d/defaults.sh
```

```sh copy filename="/etc/profile.d/defaults.sh" {3-7}
[...]
# Tor proxy
export ALL_PROXY="socks5h://localhost/var/run/tor/socks.sock"
export HTTP_PROXY="${ALL_PROXY}"
export HTTPS_PROXY="${ALL_PROXY}"
export http_proxy="${HTTP_PROXY}"
export https_proxy="${HTTPS_PROXY}"
```

* Source the changes

```sh copy
. /etc/profile.d/defaults.sh
```

* Test the configuration

```sh copy
curl -s https://check.torproject.org | grep -m 1 -e "Congratulations" -e "Sorry"
```

```sh filename="output"
Congratulations. This browser is configured to use Tor.
```

<FAQBox title="SSH through Tor">
If you want to log into your Microbolt with SSH when you're away, you can easily
do so by adding a Tor hidden service. This makes "calling home" very easy,
without the need to configure anything on your internet router.

{<h4>Server</h4>}

* Add the following lines in the "location hidden services" section, below
"`## This section is just for location-hidden services ##`" in the torrc file

<Callout type="warning">
It's interesting to put the same port as done on `dropbear`/`openssh`, default
`22`
</Callout>

```sh copy
$SU $EDITOR /etc/tor/torrc
```

```conf copy filename="/etc/tor/torrc" {5}
# Hidden Service SSH server
HiddenServiceDir /var/lib/tor/ssh/
HiddenServiceVersion 3
HiddenServicePoWDefensesEnabled 1
HiddenServicePort 2222 127.0.0.1:2222
```

* Reload the Tor configuration to apply the configuration

```sh copy
$SU rc-service tor reload
```

* Get the SSH Onion address

```sh copy
$SU cat /var/lib/tor/ssh/hostname
```

```sh filename="output"
abcdefg..............xyz.onion
```

* Save the Tor address in a secure location, e.g. your password manager

{<h4>Client</h4>}

You also need to have Tor installed on your regular computer where you start the
SSH connection. Usage of SSH over Tor differs by client and operating system.

<Tabs items={['windows', 'macOS', 'linux']}>
    <Tabs.Tab>
Popular tools like `torify` or `torsocks` are not available on Windows, and
`torifier` are abandoned.

To work around this, first, make sure Tor is installed and running on your
Windows. Run as admin:

<Callout type="warning">
First you need to install [chocolatey](https://chocolatey.org/install)
</Callout>

```sh copy
choco install tor
choco install nmap --version=7.92.0.20220321
tor --service start
```

Check tor service are working

```sh copy
netstat -aon | findstr ":9050"
```

```sh filename="output"
  TCP    127.0.0.1:9050         0.0.0.0:0              LISTENING       23656
```

You can SSH to your PC "out of the box" with the following proxy command:

```sh copy
ssh `
    -o "ProxyCommand ncat --proxy-type socks5 --proxy 127.0.0.1:9050 %h %p" `
    satoshi@abcdefg..............xyz.onion -p 2222
```

* For a more permanent solution, add these six lines below to your local SSH
config file. Choose any HOSTNICKNAME you want, save, and exit

```sh copy
notepad .ssh/config
```

```conf filename="~/.ssh/config"
Host HOSTNICKNAME
  Hostname abcdefg..............xyz.onion
  User satoshi
  Port 2222
  CheckHostIP no
  ProxyCommand ncat --proxy-type socks5 --proxy 127.0.0.1:9050 %h %p
```

* Restart Tor

```sh copy
tor --service stop
tor --service start
```

* You should now be able to SSH to your PC with

```sh copy
ssh HOSTNICKNAME
```
    </Tabs.Tab>
    <Tabs.Tab>
Using `torify` or `torsocks` may not work due to Apple's
_System Integrity Protection (SIP)_ which will deny access to `/usr/bin/ssh`.

To work around this, first, make sure Tor is installed and running on your Mac:

<Callout type="warning">
First you need to install [homebrew](https://brew.sh/)
</Callout>

```sh copy
brew install tor && brew services start tor
```

You can SSH to your PC "out of the box" with the following proxy command:

```sh
ssh \
    -o "ProxyCommand nc -X 5 -x 127.0.0.1:9050 %h %p" \
    satoshi@abcdefg..............xyz.onion -p 2222
```

* For a more permanent solution, add these six lines below to your local SSH
config file. Choose any HOSTNICKNAME you want, save, and exit

```sh copy
vi .ssh/config
```

```conf filename="~/.ssh/config"
Host HOSTNICKNAME
  Hostname abcdefg..............xyz.onion
  User satoshi
  Port 2222
  CheckHostIP no
  ProxyCommand /usr/bin/nc -x localhost:9050 %h %p
```

* Restart Tor

```sh copy
brew services restart tor
```

* You should now be able to SSH to your PC with

```sh copy
ssh HOSTNICKNAME
```
    </Tabs.Tab>
    <Tabs.Tab>
* Use `torify` or `torsocks`, both work similarly; just use whatever you have
available

```sh
torify ssh admin@abcdefg..............xyz.onion -p 2222
```

```sh
torsocks ssh admin@abcdefg..............xyz.onion -p 2222
```
    </Tabs.Tab>
</Tabs>
</FAQBox>

## I2P Project

[I2P](https://geti2p.net) is a universal anonymous network layer. All
communications over I2P are anonymous and end-to-end encrypted, participants
don't reveal their real IP addresses. I2P allows people from all around the
world to communicate and share information without restrictions.

I2P client is software used for building and using anonymous I2P networks. Such
networks are commonly used for anonymous peer-to-peer applications (filesharing,
cryptocurrencies) and anonymous client-server applications (websites, instant
messengers, chat-servers).

We are to use [i2pd](https://i2pd.readthedocs.io/en/latest/) (I2P Daemon), a
full-featured C++ implementation of the I2P client, as a Tor network complement.

### I2P installation

```sh copy
$SU apk add i2pd
```

### I2P configuration

* Add the following lines to the I2P `conf.d` file in order to disable the
services that we don't need

```sh copy
printf "%s\n" \
    "I2PD_OPTIONS=\"\${I2PD_OPTIONS}" \
    "--ntcp2.enabled=true" \
    "--ssu2.enabled=true" \
    "--http.enabled=false" \
    "--httpproxy.enabled=false" \
    "--socksproxy.enabled=false" \
    "--sam.enabled=true" \
    "--bob.enabled=false" \
    "--i2cp.enabled=false" \
    "--i2pcontrol.enabled=false" \
    "--upnp.enabled=false" \
    "\"" \
    | $SU tee -a /etc/conf.d/i2pd
```

* Start the i2p service and add to runlevel

```sh copy
$SU rc-service i2pd start
$SU rc-update add i2pd default
```

* Ensure that the i2pd service is working and listening at the default ports

```sh copy
$SU netstat -lntup | grep LISTEN | grep i2pd
```

```sh filename="output"
tcp        0      0 127.0.0.1:6668          0.0.0.0:*               LISTEN      11060/i2pd
tcp        0      0 127.0.0.1:7656          0.0.0.0:*               LISTEN      11060/i2pd
tcp        0      0 0.0.0.0:23178           0.0.0.0:*               LISTEN      11060/i2pd
```

* See `i2p` in action by monitoring its log file. Exit with `Ctrl-C`

```sh copy
$SU tail -f /var/log/i2pd/i2pd.log
```

## DNSCrypt proxy

[DNSCrypt](https://www.dnscrypt.info) is a protocol that authenticates
communications between a DNS client and a DNS resolver. It prevents DNS
spoofing. It uses cryptographic signatures to verify that responses originate
from the chosen DNS resolver and haven't been tampered with.

<Callout type="error">
This is not recommended if DNS queries to external servers are blocked at the
router/firewall level in your local network. Blocking DNS queries at the
firewall/router level would be the correct way to address this issue. Proceed
with caution.
</Callout>

### Preparations

<Steps>
#### Install dependencies

```sh copy
$SU apk add --virtual .build-dep minisign
```

```sh copy
$SU apk add bind-tools
```

#### Create the `dnscrypt` user/group

```sh copy
$SU addgroup -S dnscrypt
```

```sh copy
$SU adduser \
    -S \
    -D \
    -H \
    -h /dev/null \
    -s /sbin/nologin \
    -G dnscrypt \
    -g dnscrypt \
    dnscrypt
```

* Add the user satoshi to the group dnscrypt

```sh copy
$SU adduser satoshi dnscrypt
```

#### Download latest release

```sh copy
cd /tmp
LATEST=$(curl -s https://api.github.com/repos/DNSCrypt/dnscrypt-proxy/releases/latest | grep "tag_name" | cut -d '"' -f 4 | sed 's/^v//')
curl -OL https://github.com/DNSCrypt/dnscrypt-proxy/releases/download/$LATEST/dnscrypt-proxy-linux_${ARCH//amd64/x86_64}-${LATEST}.tar.gz \
     -OL https://github.com/DNSCrypt/dnscrypt-proxy/releases/download/$LATEST/dnscrypt-proxy-linux_${ARCH//amd64/x86_64}-${LATEST}.tar.gz.minisig
```

#### Verify the signature

```sh copy
minisign \
    -Vm dnscrypt-proxy-linux_${ARCH//amd64/x86_64}-${LATEST}.tar.gz \
    -P RWTk1xXqcTODeYttYMCMLo0YJHaFEHn7a3akqHlb/7QvIQXHVPxKbjB5
```

```sh filename="output"
Signature and comment signature verified
[...]
```
</Steps>

### Installation

<Steps>
#### Extract and install binary

```sh copy
tar xzf dnscrypt-proxy-linux_${ARCH//amd64/x86_64}-${LATEST}.tar.gz
```

* Create the necessary directories and copy the binary and configuration file

```sh copy
$SU mkdir -p /etc/dnscrypt-proxy
```

```sh copy
$SU cp linux-${ARCH//amd64/x86_64}/dnscrypt-proxy /usr/bin/
$SU cp linux-${ARCH//amd64/x86_64}/example-dnscrypt-proxy.toml /etc/dnscrypt-proxy/dnscrypt-proxy.toml
```

#### Cleanup

```sh copy
cd
$SU apk del .build-dep
$SU rm -rf /tmp/dnscrypt-proxy-linux_${ARCH//amd64/x86_64}-${LATEST}* /tmp/linux-${ARCH//amd64/x86_64}
```
</Steps>

### Configuration

<Steps>
#### Edit the DNSCrypt configuration file

```sh copy
$SU $EDITOR /etc/dnscrypt-proxy/dnscrypt-proxy.toml
```

```toml copy filename="/etc/dnscrypt-proxy/dnscrypt-proxy.toml" {3,6,9,12,15,18,21,24,28}
[...]
# Use servers reachable over IPv4
ipv4_servers = true

# Use servers reachable over IPv6 -- Do not enable if you don't have IPv6 connectivity
ipv6_servers = false

# Use servers implementing the DNSCrypt protocol
dnscrypt_servers = true

# Use servers implementing the DNS-over-HTTPS protocol
doh_servers = true

# Use servers implementing the Oblivious DoH protocol
odoh_servers = false
[...]
# Server must support DNS security extensions (DNSSEC)
require_dnssec = false

# Server must not log user queries (declarative)
require_nolog = true

# Server must not enforce its own blacklist (for parental control, ads blocking...)
require_nofilter = true
[...]
## Skip resolvers incompatible with anonymization instead of using them directly

skip_incompatible = false
[...]
```

<Callout type="info">
You can learn more about the configuration options in the [official
documentation](https://github.com/DNSCrypt/dnscrypt-proxy/wiki/Configuration)
</Callout>

<FAQBox title="Anonymized DNS">
If you want to anonymize your DNS queries, you can use the `[anonymized_dns]`
option. This will route your DNS queries through anonymous relays. Read more
about this
[here](https://github.com/DNSCrypt/dnscrypt-proxy/wiki/Anonymized-DNS).

You can find a complete list of available relays
[here](https://github.com/DNSCrypt/dnscrypt-resolvers/blob/master/v3/relays.md).

You need to disable the servers you use as relays by adding them to
`disabled_server_names` using the `via=[...]` option. These are just examples;
you need to find the appropriate servers for your needs.

Using `{ server_name='*', via=['*'] }` is also an option, but it is not
recommended. While dnscrypt-proxy will pick a relay on a distinct network, this
does not guarantee that the server and relay are run by different entities.

```toml copy filename="/etc/dnscrypt-proxy/dnscrypt-proxy.toml" {3,6,9,12,15,18,21,24,27,29-34,38}
[...]
# Use servers reachable over IPv4
ipv4_servers = true

# Use servers reachable over IPv6 -- Do not enable if you don't have IPv6 connectivity
ipv6_servers = false

# Use servers implementing the DNSCrypt protocol
dnscrypt_servers = true

# Use servers implementing the DNS-over-HTTPS protocol
doh_servers = false

# Use servers implementing the Oblivious DoH protocol
odoh_servers = false
[...]
# Server must support DNS security extensions (DNSSEC)
require_dnssec = false

# Server must not log user queries (declarative)
require_nolog = true

# Server must not enforce its own blacklist (for parental control, ads blocking...)
require_nofilter = true

# Server names to avoid even if they match all criteria
disabled_server_names = ['cs-barcelona', 'portland-ipv4']
[...]
[anonymized_dns]

routes = [
    { server_name='*', via=['anon-cs-barcelona', 'dnscry.pt-anon-portland-ipv4'] },
    { server_name='circl-doh', via=['anon-cs-barcelona', 'dnscry.pt-anon-portland-ipv4'] }
]
[...]
## Skip resolvers incompatible with anonymization instead of using them directly

skip_incompatible = true
[...]
```
</FAQBox>

#### Create the DNSCrypt service

```sh copy
$SU $EDITOR /etc/init.d/dnscrypt-proxy
```

```sh copy filename="/etc/init.d/dnscrypt-proxy"
#!/sbin/openrc-run

: ${DNSCRYPT_PROXY_CONFIGFILE:=/etc/${RC_SVCNAME}/${RC_SVCNAME}.toml}
: ${DNSCRYPT_PROXY_CACHEDIR:=/var/cache/${RC_SVCNAME}}
: ${DNSCRYPT_PROXY_LOGDIR:=/var/log/${RC_SVCNAME}}
: ${DNSCRYPT_PROXY_USER:=dnscrypt}
: ${DNSCRYPT_PROXY_GROUP:=dnscrypt}
: ${DNSCRYPT_PROXY_BIN:=/usr/bin/${RC_SVCNAME}}
: ${DNSCRYPT_PROXY_OPTS=${DNSCRYPT_PROXY_OPTS}}
: ${DNSCRYPT_PROXY_SIGTERM_TIMEOUT:=600}

DNSCRYPT_PROXY_PIDDIR="/run/${RC_SVCNAME}"

name="DNSCrypt client proxy"
description="Encrypted/authenticated DNS proxy"

required_files="${DNSCRYPT_PROXY_CONFIGFILE}"
pidfile="${DNSCRYPT_PROXY_PIDDIR}/${RC_SVCNAME}.pid"
retry="${DNSCRYPT_PROXY_SIGTERM_TIMEOUT}"
capabilities="^cap_net_bind_service"

command="${DNSCRYPT_PROXY_BIN}"
command_args="-config ${DNSCRYPT_PROXY_CONFIGFILE}
              ${DNSCRYPT_PROXY_OPTS}"
command_user="${DNSCRYPT_PROXY_USER}:${DNSCRYPT_PROXY_GROUP}"
command_background="true"

start_stop_daemon_args="--stdout ${DNSCRYPT_PROXY_LOGDIR}/debug.log
                        --stderr ${DNSCRYPT_PROXY_LOGDIR}/debug.log"

depend() {
  use logger net
  provide dns
}

start_pre() {
    checkpath --file      --mode 0660 --owner "${command_user}" "${DNSCRYPT_PROXY_CONFIGFILE}"
    checkpath --directory --mode 0755 --owner "${command_user}" "${DNSCRYPT_PROXY_CACHEDIR}"
    checkpath --directory --mode 0755 --owner "${command_user}" "${DNSCRYPT_PROXY_LOGDIR}"
    checkpath --directory --mode 0755 --owner "${command_user}" "${DNSCRYPT_PROXY_PIDDIR}"
}
```

* Enable execution permission

```sh copy
$SU chmod +x /etc/init.d/dnscrypt-proxy
```

#### Enable and start the DNSCrypt service

```sh copy
$SU rc-service dnscrypt-proxy start
$SU rc-update add dnscrypt-proxy
```

#### Ensure that the DNSCrypt service is working

```sh copy
$SU netstat -lntup | grep LISTEN | grep dnscrypt
```

```sh filename="output"
tcp        0      0 127.0.0.1:53            0.0.0.0:*               LISTEN      18433/dnscrypt-prox
```

#### Setup DNS

<Callout type="warning">
Depending on your network configuration, you may need to change the DNS server
in the interface configuration file or in the DHCP server configuration.

Interface config setup `$SU setup-interfaces` or edit →
`/etc/network/interfaces`
</Callout>

```sh copy
$SU setup-dns 127.0.0.1
```

```sh copy
printf "%s\n" "options edns0" | $SU tee -a /etc/resolv.conf
```

#### Block/redirect unencrypted external DNS queries

<Callout type="warning">
This is highly discouraged if you have a firewall/router that can block DNS
queries. This is a last resort if you can't block DNS queries at the router
level.
</Callout>

* Load the necessary kernel modules and load them at boot

```sh copy
$SU modprobe -v iptable_nat
```

```sh copy
printf "%s\n" \
        "iptable_nat" \
        | $SU tee -a /etc/modules-load.d/awall.conf
```

<Tabs items={['awall', 'ufw']}>
    <Tabs.Tab>
* Create the following `block-dns.json` file

```sh copy
$SU $EDITOR /etc/awall/optional/block-dns.json
```

```json copy filename="/etc/awall/optional/block-dns.json"
{
    "description": "Block external DNS queries",

    "dnat": [
        {
            "in": "_fw",
            "dest": "0.0.0.0/0",
            "service": [
                { "proto": "tcp", "port": 53 },
                { "proto": "udp", "port": 53 }
            ],
            "to-addr": "127.0.0.1",
            "to-port": 53
        }
    ]
}
```

* Apply the configuration

```sh copy
$SU awall enable block-dns
$SU awall activate
```
    </Tabs.Tab>
    <Tabs.Tab>
* Make the rules directly in `iptables`, `ufw` doesn't support this

```sh copy
$SU iptables -t nat -A OUTPUT -p udp --dport 53 -j DNAT --to-destination 127.0.0.1:53
$SU iptables -t nat -A OUTPUT -p tcp --dport 53 -j DNAT --to-destination 127.0.0.1:53
```
    </Tabs.Tab>
</Tabs>

</Steps>

### Test configuration

```sh copy
nslookup microbolt.guide
```

```sh filename="output" {1-2}
Server:         127.0.0.1
Address:        127.0.0.1#53

Non-authoritative answer:
Name:   microbolt.guide
Address: 76.76.21.21
```

* You can monitor DNSCrypt logs by entering this command. Exit with `Ctrl + C`

```sh copy
tail -f /var/log/dnscrypt-proxy/debug.log
```